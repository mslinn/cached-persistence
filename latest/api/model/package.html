<!DOCTYPE html >
<html>
        <head>
          <title>model - model</title>
          <meta name="description" content="model - model" />
          <meta name="keywords" content="model model" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript" src="../lib/jquery.js" id="jquery-js"></script>
      <script type="text/javascript" src="../lib/jquery-ui.js"></script>
      <script type="text/javascript" src="../lib/template.js"></script>
      <script type="text/javascript" src="../lib/tools.tooltip.js"></script>
      
      <script type="text/javascript">
         if(top === self) {
            var url = '../index.html';
            var hash = 'model.package';
            var anchor = window.location.hash;
            var anchor_opt = '';
            if (anchor.length >= 1)
              anchor_opt = '@' + anchor.substring(1);
            window.location.href = url + '#' + hash + anchor_opt;
         }
   	  </script>
    
        </head>
        <body class="value">
      <div id="definition">
        <img alt="Package" src="../lib/package_big.png" />
        
        <h1>model</h1><span class="permalink">
      <a href="../index.html#model.package" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <span class="name">model</span>
      </span>
      </h4>
      
          <div id="comment" class="fullcommenttop"></div>
        

      <div id="mbrsel">
        <div id="textfilter"><span class="pre"></span><span class="input"><input id="mbrsel-input" type="text" accesskey="/" /></span><span class="post"></span></div>
        
        
        <div id="visbl">
            <span class="filtertype">Visibility</span>
            <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
          </div>
      </div>

      <div id="template">
        <div id="allMembers">
        

        

        

        <div id="values" class="values members">
              <h3>Value Members</h3>
              <ol><li name="model.persistence" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="persistence"></a>
      <a id="persistence:persistence"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a href="persistence/package.html"><span class="name">persistence</span></a>
      </span>
      </h4><span class="permalink">
      <a href="../index.html#model.package@persistence" title="Permalink" target="_top">
        <img src="../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt"><img src='https://raw.githubusercontent.com/mslinn/quill-cache/media/quill-cache.jpg' align='right' width='33%'></p><div class="fullcomment"><div class="comment cmt"><p><img src='https://raw.githubusercontent.com/mslinn/quill-cache/media/quill-cache.jpg' align='right' width='33%'></p><h4> Features and Benefits </h4><ul><li>Dramatically reduces time to fetch results from read-mostly database tables</li><li>Database-independent <a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete" target="_blank">CRUD</a> API (<code>insert</code>, <code>deleteById</code>, <code>remove</code>, <code>update</code>, <code>upsert</code>, <code>zap</code>, <code>findAll</code>,
    <code>findById</code>, plus application-specific finders)</li><li>Thin, light type-safe API</li><li>Provides compatible interface to read-write database tables</li><li>Multiple databases can be configured, with configurations for development, testing, production, etc.</li><li>Choice of caching strategy (strong, soft or none)</li><li>Very little boilerplate (convention over configuration)</li><li>Switching databases only requires changing one word in a program</li><li>Play Framework evolution format support</li><li>ScalaTest unit test setup</li><li><a href="https://github.com/mslinn/quill-gen" target="_blank">DAO code generator available</a></li></ul><h4> Background </h4><p> Scala uses case classes for modeling domain objects.
<code>quill-cache</code> optimizes database access for read-mostly domain objects by providing a caching layer overtop
<a href="https://github.com/getquill/quill" target="_blank">Quill</a>.
This library depends on <a href="https://github.com/mslinn/has-id" target="_blank">has-id</a>, and case classes that need to be cached must extend
<a href="http://mslinn.github.io/has-id/latest/api/#model.persistence.HasId" target="_blank">HasId</a>.
<code>HasId</code> is generic and quite flexible, so you are encouraged to subclass all your domain objects from <code>HasId</code>,
even if they do not require database caching.</p><p>The current version of this library has no provision for distributed caches.
This could be retrofitted, however the author did not have the need, so the work was not done.</p><h4> DAOs </h4><p>The <a href="https://en.wikipedia.org/wiki/Data_access_object" target="_blank">data access object pattern</a> (DAO) is common across all computer languages.
DAOs for case classes that require database caching must extend the <a href="persistence/CachedPersistence.html" class="extype" name="model.persistence.CachedPersistence">persistence.CachedPersistence</a> abstract class.</p><p>You are free to name DAOs anything you like; this library does not mandate any naming convention.
Scala DAOs are often given the same name as the class that they persist, but with a suffix indicating plurality.
For example, if a case class named <code>Point</code> needs to be persisted, the DAO is usually called <code>Points</code>.
Unlike some other persistence libraries for Scala, Quill allows you to define your DAO in the case class's companion object,
so you also have that option when using this library.</p><p>This library provides each DAO with its own cache.
DAOs that extend <code>CachedPersistence</code> have a method called <code>preload()</code>
which your application's initialization must invoke in order to fill that DAO's cache.
A cache can be flushed by calling the DAO's <code>flushCache()</code> method.
Because <code>preload()</code> always flushes the cache before loading it you probably won't ever need to explicitly call <code>flushCache()</code>.</p><h4> Cache Types </h4><p>Two types of caches are supported by <code>CachedPersistence</code>:</p><ul><li><a href="http://mslinn.github.io/scalacourses-utils/latest/api/com/micronautics/cache/StrongCache.html" target="_blank">StrongCache</a>,
    which is locked into memory until the cache is explicitly flushed.
    Mix the <a href="http://mslinn.github.io/quill-cache/latest/api/#model.persistence.StrongCacheLike" target="_blank">StrongCacheLike</a>
    trait into the DAO to provide this behavior.
    This type of cache is useful when there is enough memory to hold all instances of the case class.</li><li><a href="http://mslinn.github.io/scalacourses-utils/latest/api/com/micronautics/cache/SoftCache.html" target="_blank">SoftCache</a>,
     which contains &quot;soft&quot; values that might expire by timing out or might get bumped if memory fills up.
     Mix the <a href="http://mslinn.github.io/quill-cache/latest/api/#model.persistence.SoftCacheLike" target="_blank">SoftCacheLike</a>
     trait into the DAO to provide this behavior.
     DAOs that mix in <code>SoftCacheLike</code> do not assume that all instances of the case class can fit into memory.
     <code>SoftCacheLike</code> finders query the database after every cache miss.
     Because of this, <code>SoftCacheLike</code> finders run more slowly than <code>StrongCacheLike</code> finders when the cache does not contain the desired value.
     This trait is experimental, do not use in production.</li></ul><p>Caches require an <a href="http://www.scala-lang.org/api/current/scala/concurrent/ExecutionContext.html" target="_blank">ExecutionContext</a>,
and the unit tests provide one:</p><pre><span class="kw">package</span> model.dao

<span class="kw">import</span> model.persistence.CacheExecutionContext
<span class="kw">import</span> scala.concurrent.{ExecutionContext, ExecutionContextExecutor}

<span class="cmt">/** Just delegates to standard Scala ExecutionContext, you can make this do whatever you want */</span>
<span class="kw">object</span> TestExecutionContext <span class="kw">extends</span> CacheExecutionContext {
  <span class="kw">protected</span> <span class="kw">val</span> ec: ExecutionContextExecutor = ExecutionContext.Implicits.global
  <span class="kw">override</span> <span class="kw">def</span> execute(runnable: Runnable): <span class="std">Unit</span> = ec.execute(runnable)

  <span class="kw">override</span> <span class="kw">def</span> reportFailure(cause: Throwable): <span class="std">Unit</span> = ec.reportFailure(cause)
}</pre><h4> Consistent APIs for Cached and Uncached DAOs </h4><p><a href="persistence/CachedPersistence.html" class="extype" name="model.persistence.CachedPersistence">persistence.CachedPersistence</a> subclasses <a href="persistence/UnCachedPersistence.html" class="extype" name="model.persistence.UnCachedPersistence">persistence.UnCachedPersistence</a>,
which you can use to derive DAOs for case classes that must have direct access to the database so the case classes are not cached.
You don't have to subclass <code>UnCachedPersistence</code> to get this behavior, but if you do then the DAOs for your cached
domain objects will have the same interface as the DAOs for your uncached domain objects,
and your code's structure will be more consistent.</p><h4> Configuration </h4><p>Your database configuration is specified by a HOCON file called <code>application.conf</code> on the classpath.
Please see <code>src/main/scala/resources/reference.conf</code> for an example of how to set that up.</p><p>Here is an excerpt showing configuration for H2 and Postgres databases.
Only one of these databases can be active per database context:</p><pre>quill-cache {
  h2 {
    dataSourceClassName = org.h2.jdbcx.JdbcDataSource
    dataSource {
      url = <span class="lit">"jdbc:h2:tcp://localhost/./h2data;DB_CLOSE_ON_EXIT=FALSE"</span>
      url = ${?H2_URL}

      user = sa
      user = ${?H2_USER}

      password = <span class="lit">""</span>
      password = ${?H2_PASSWORD}
    }
  }

  postgres {
    connectionTimeout = <span class="num">30000</span>
    dataSource {
      databaseName = ${?DB}
      password = ${?PGPASSWORD}

      portNumber = <span class="num">5432</span>
      portNumber = ${?PGPORT}

      serverName = localhost
      serverName = ${?PGHOST}

      ssl = <span class="kw">true</span>
      sslfactory = <span class="lit">"org.postgresql.ssl.NonValidatingFactory"</span>
      #url = <span class="lit">""</span>

      user = postgres
      user = ${?USERID}
    }
    dataSourceClassName = <span class="lit">"org.postgresql.ds.PGSimpleDataSource"</span>
    maximumPoolSize = <span class="num">100</span>
  }
}</pre><p>The <code>quill-cache</code> section of the configuration file specifies parameters for this library:</p><ul><li>You can make up your own subsections and call them whatever you want.</li><li>The contents of the named subsections are database dependent.</li><li><a href="https://github.com/brettwooldridge/HikariCP#configuration-knobs-baby" target="_blank">Hikari</a> interprets the meaning of the <code>dataSource</code> sections.</li></ul><p>See also <a href="https://github.com/getquill/quill/blob/master/quill-jdbc/src/test/resources/application.conf" target="_blank">the Quill test application.conf</a>,
<a href="https://github.com/brettwooldridge/HikariCP#initialization" target="_blank">Hikari initialization</a>,
<a href="https://github.com/brettwooldridge/HikariCP/blob/master/src/main/java/com/zaxxer/hikari/HikariConfig.java#L63-L97" target="_blank">HikariConfig.java</a>, and
<a href="https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing#the-formula" target="_blank">Hikari pool sizing</a></p><h4> Working with quill-cache </h4><h5> Quill Contexts </h5><p>Quill-cache provides many flavors of Quill contexts, one for each type of supported database driver.
Each context is exposed as an <code>abstract class</code>.
Import the Quill context <code>ctx</code> from the appropriate type wherever you need to access the database.</p><p>Available abstract classes are: <code>H2Ctx</code>, <code>MySqlCtx</code>, <code>PostgresCtx</code>, and <code>SqliteCtx</code>.
Subclass the appropriate <code>abstract class</code> for the type of database driver you need, like this:</p><pre><span class="kw">class</span> MyClass <span class="kw">extends</span> model.persistence.H2Ctx</pre><h5> Asynchronous Drivers </h5><p>Asynchronous drivers are not currently supported by <code>quill-cache</code>, but there is an
<a href="https://github.com/mslinn/quill-cache/issues/2" target="_blank">open issue for this enhancement</a>.
The database contexts <code>MysqlAsyncCtx</code> and <code>PostgresAsyncCtx</code> were written in anticipation of async support.</p><h5> Best Practice </h5><p>Define a trait called <code>SelectedCtx</code>, and mix it into all your DAOs.
<code>SelectedCtx</code> merely extends the database context used in your application.
The <code>PersistenceTest</code> DAO in <code>test/scala/model/dao</code> follows this pattern:</p><pre><span class="kw">trait</span> SelectedCtx <span class="kw">extends</span> model.persistence.H2Ctx</pre><p>Now define your application's Quill context as a singleton, and mix in the predefined implicits for Quill-cache defined in <code>QuillCacheImplicits</code>.</p><pre><span class="kw">package</span> model

<span class="kw">import</span> model.dao.SelectedCtx
<span class="kw">import</span> persistence.QuillCacheImplicits

<span class="kw">case</span> <span class="kw">object</span> Ctx <span class="kw">extends</span> SelectedCtx <span class="kw">with</span> QuillCacheImplicits</pre><p>If you have more implicits to mix in, define a trait in the same manner as <code>QuillCacheImplicits</code> and mix it in as well:</p><pre><span class="kw">trait</span> MyQuillImplicits { ctx: JdbcContext[_, _] <span class="kw">=&gt;</span>
  <span class="cmt">// define Quill Decoders, Encoders and Mappers here</span>
}</pre><p>After adding in <code>MyQuillImplicits</code>, your revised application Quill context <code>Ctx</code> is now:</p><pre><span class="kw">package</span> model

<span class="kw">import</span> model.dao.SelectedCtx
<span class="kw">import</span> persistence.QuillCacheImplicits

<span class="kw">case</span> <span class="kw">object</span> Ctx <span class="kw">extends</span> SelectedCtx <span class="kw">with</span> QuillCacheImplicits <span class="kw">with</span> MyQuillImplicits</pre><p>Now import the Quill context's internally defined implicits into your DAO's scope.
Here are two examples of how to do that, one for cached and one for uncached persistence.
Notice that <code>Users</code> and <code>Tokens</code> are singletons, which makes them easy to work with.
Here is <code>Users</code>, a DAO with a strong cache, which means it needs an <code>ExecutionContext</code> like <code>TestExecutionContext</code>,
which is in scope because it resides in the same package:</p><pre><span class="kw">import</span> model.{Ctx, User}
<span class="kw">import</span> model.persistence._

<span class="kw">object</span> Users <span class="kw">extends</span> CachedPersistence[<span class="std">Long</span>, <span class="std">Option</span>[<span class="std">Long</span>], User]
    <span class="kw">with</span> StrongCacheLike[<span class="std">Long</span>, <span class="std">Option</span>[<span class="std">Long</span>], User] {
  <span class="kw">import</span> Ctx._

  <span class="cmt">// DAO code for User goes here</span>
}</pre><p>Here is <code>Tokens</code>, a DAO without any cache, which means it does not need an <code>ExecutionContext</code>:</p><pre><span class="kw">import</span> model.{Ctx, Token}
<span class="kw">import</span> model.persistence._

<span class="kw">object</span> Tokens <span class="kw">extends</span> UnCachedPersistence[<span class="std">Long</span>, <span class="std">Option</span>[<span class="std">Long</span>], Token] {
 <span class="kw">import</span> Ctx._

 <span class="cmt">// DAO code for Token goes here</span>
}</pre><h4> Multiple Database Contexts </h4><p>For circumstances where more than one database contexts need to share the same HikariCP pool, first construct a context,
then other contexts can be created from the first context's <code>dataSource</code>. In the following example, a context for an H2 database
is created using <code>Ctx.dataSource</code>:</p><pre><span class="kw">case</span> <span class="kw">object</span> Ctx2 <span class="kw">extends</span> H2Ctx(Ctx.dataSource) <span class="kw">with</span> MySpecialImplicits</pre><p>Note that the new context need not have the same implicit decoders, encoders or mappers as the original context.
See the <code>ContextTest</code> unit test for a working example.</p><p>Here is another way to set this up:</p><pre><span class="cmt">/** This causes a new Hikari pool to be created */</span>
<span class="kw">object</span> AuthCtx <span class="kw">extends</span> PostgresCtx <span class="kw">with</span> QuillCacheImplicits <span class="kw">with</span> IdImplicitLike

<span class="kw">abstract</span> <span class="kw">class</span> DerivedCtx(dataSource: DataSource <span class="kw">with</span> Closeable)
  <span class="kw">extends</span> PostgresCtx(dataSource) <span class="kw">with</span> QuillCacheImplicits <span class="kw">with</span> IdImplicitLike

<span class="cmt">/** Reuse the HikariCP pool from [[AuthCtx]] */</span>
<span class="kw">object</span> Ctx <span class="kw">extends</span> DerivedCtx(AuthCtx.dataSource) <span class="kw">with</span> MySpecialImplicits</pre><h4> Working with DAOs </h4><p><code>Quill-cache</code> automatically defines a read-only property for each DAO, called <code>className</code>.
This property is derived from the unqualified name of the case class persisted by the DAO.
For example, if <code>model.User</code> is being persisted, <code>className</code> will be <code>User</code>.</p><p>Each DAO needs the following functions defined:</p><ol class="decimal"><li><code>_findAll</code>     &ndash; Quill query foundation - Encapsulates the Quill query that returns all instances of the case class from the database.</li><li><code>_deleteById</code>  &ndash; Encapsulates the Quill query that deletes the instance of the case class with the given <code>Id</code> from the database.</li><li><code>_findById</code>    &ndash; Encapsulates the Quill query that optionally returns the instance of the case class from
                            the database with the given <code>Id</code>, or <code>None</code> if not found.</li><li><code>_insert</code>      &ndash; Encapsulates the Quill query that inserts the given instance of the case class into the
                            database, and returns the case class as it was stored, including any auto-increment fields.</li><li><code>_update</code>      &ndash; Encapsulates the Quill query that updates the given instance of the case class into the
                            database, and returns the entity. Throws an Exception if the case class was not previously persisted.</li></ol><h4> DAO CRUD </h4><p>Here is an example of the CRUD-related functions, implemented in the DAO for <code>model.User</code> in the <code>quill-cache</code> unit test suite.</p><pre><span class="ano">@inline</span> <span class="kw">def</span> _findAll: <span class="std">List</span>[User] = run { quote { query[User] } }

<span class="kw">val</span> queryById: IdOptionLong <span class="kw">=&gt;</span> Quoted[EntityQuery[User]] =
  (id: IdOptionLong) <span class="kw">=&gt;</span>
    quote { query[User].filter(_.id == lift(id)) }

<span class="kw">val</span> _deleteById: (IdOptionLong) <span class="kw">=&gt;</span> <span class="std">Unit</span> =
  (id: IdOptionLong) <span class="kw">=&gt;</span> {
    run { quote { queryById(id).delete } }
    ()
  }

<span class="kw">val</span> _findById: IdOptionLong <span class="kw">=&gt;</span> <span class="std">Option</span>[User] =
  (id: Id[<span class="std">Option</span>[<span class="std">Long</span>]]) <span class="kw">=&gt;</span>
    run { quote { queryById(id) } }.headOption

<span class="kw">val</span> _insert: User <span class="kw">=&gt;</span> User =
  (user: User) <span class="kw">=&gt;</span> {
    <span class="kw">val</span> id: Id[<span class="std">Option</span>[<span class="std">Long</span>]] = <span class="kw">try</span> {
      run { quote { query[User].insert(lift(user)) }.returning(_.id) }
    } <span class="kw">catch</span> {
      <span class="kw">case</span> e: Throwable <span class="kw">=&gt;</span>
        logger.error(e.getMessage)
        <span class="kw">throw</span> e
    }
    user.setId(id)
  }

<span class="kw">val</span> _update: User <span class="kw">=&gt;</span> User =
  (user: User) <span class="kw">=&gt;</span> {
    run { queryById(user.id).update(lift(user)) }
    user
  }</pre><p>With the above defined, <code>quill-cache</code> automatically provides the following CRUD-related methods for each DAO.
Only finders can take advantage of a cache, if present:</p><pre><span class="ano">@inline</span> <span class="kw">def</span> deleteById(id: Id[_IdType]): <span class="std">Unit</span>
<span class="ano">@inline</span> <span class="kw">override</span> <span class="kw">def</span> findAll: <span class="std">List</span>[User]
<span class="kw">def</span> findById(id: Id[_IdType]): <span class="std">Option</span>[User]
<span class="ano">@inline</span> <span class="kw">def</span> insert(user: User): User
<span class="ano">@inline</span> <span class="kw">def</span> update(user: User): User
<span class="ano">@inline</span> <span class="kw">def</span> remove(user: User): <span class="std">Unit</span>
<span class="ano">@inline</span> <span class="kw">def</span> upsert(user: User): User
<span class="ano">@inline</span> <span class="kw">def</span> zap(): <span class="std">Unit</span></pre><p>See the unit tests for examples of how to use this library.</p></div></div>
    </li></ol>
            </div>

        

        
        </div>

        <div id="inheritedMembers">
        
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>


    </body>
      </html>
